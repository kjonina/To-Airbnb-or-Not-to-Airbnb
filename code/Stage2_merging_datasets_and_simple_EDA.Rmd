
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r echo=FALSE, warning=FALSE, message=FALSE}

library(tidyverse)
library(ggplot2)
library(dplyr)
library(stringr)
library(knitr)
library(plotly)
library(forcats)
library(crosstalk)
library(here)
library(camcorder)

options(scipen = 999)

```




## Files submitted
- listings.csv - AirBnB listings in Ireland from the beginning of AirBnB operating in Ireland

- calendar.csv - AirBnB listings from 1st July 2025 to 25th July (dates not chosen by student, supplied by AirBnB), contains 9 million rows.

- rent_pressure_zones.csv -RTZs (RPZs) were developed by the Irish government to tackle rising rents lack of affordable rental units. These are areas located in parts of the country where rents are the highest and rising, and where households have the greatest difficulty finding affordable accommodation (Residential Tenancies Board, 2024). The csv was manually created from RTB website. 

- rent_in_ireland.csv - The website daft.ie is the leading property website in Ireland, which publishes reports on the Irish housing market every quarter. For this next dataset, the report Q1 2024 was used to find out the rent in each city and county in Ireland (Lyons, 2024). The csv was manually created from the report. 


## Stage 1
Due to the 9 million rows in calendar.csv, it was decided to treat this dataset outside of this analysis due to the size of it. 

- calendar_df.Rmd - Code to treat calendar.csv and create the two datasets below to analyse in this report
- summarise_df.csv - A new dataset from calendar.csv  was created, where listings were examined by availability for each month within a year (1st July 2024 to 28th June 2025).
- available_nights_df.csv - A new dataset summarising the number of available nights for each listing in a year (1st July 2024 to 28th June 2025).
- calendar_df.html - Document presents calendar_df.Rmd in HTML

## Reading in the Airbnb Listings Data

```{r}

DIRECTORY = "data_2024"

# specifying the path to the CSV file
file_path <- here(DIRECTORY, "listings.csv")


# Read the CSV file
df <- read_csv(file_path)

df <- df%>%
  arrange(id)


df$id <- as.factor(df$id)

```

In 'df' dataset, there are `r nrow(df) ` rows and `r ncol(df)` columns. Columns names are  `r colnames(df)`.

```{r}
#check the class of df
class(df)
```

```{r}
#check the column names for  df
colnames(df)
```

```{r}
# examining the structure in df
str(df)
```

```{r}
# examining the top 5 rows in df
head(df)
```

```{r}
# examining summary of all numeric columns in df
summary(df)
```

```{r echo=FALSE}
nrow(df)
```

```{r echo=FALSE}
n_distinct(df$id)
```


### Neighbourhood (renamed to 'lea')
Values in neighboourhood column had figures such as 'lea-5' so the dash and the number were removed. 
Some neighbourhood values were replaced to ensure that they match joins later. 

```{r echo=FALSE}
# declaring column as a factor
df$neighbourhood <- as.factor(df$neighbourhood)
df$neighbourhood_group <- as.factor(df$neighbourhood_group)
```

```{r echo=FALSE}
# Getting 
df$neighbourhood <- str_replace(df$neighbourhood, '-7', '')
df$neighbourhood <- str_replace(df$neighbourhood, '-6', '')
df$neighbourhood <- str_replace(df$neighbourhood, '-5', '')
df$neighbourhood <- str_replace(df$neighbourhood, '-4', '')
df$neighbourhood <- str_replace(df$neighbourhood, '-3', '')
df$neighbourhood <- str_replace(df$neighbourhood, '-3', '')
df$neighbourhood <- str_replace(df$neighbourhood, '-lea-7', ' LEA')
df$neighbourhood <- str_replace(df$neighbourhood, '-LEA', ' LEA')

# neighbourhood column is really 'lea'
df <- rename(df, lea=neighbourhood)

# declaring column as a factor
df$lea <- as.factor(df$lea)
```

```{r echo=FALSE}
# some values were still incorrect so they were manually changed
df$lea <- str_replace_all(df$lea, c('Graiguecullen -Portarlington LEA ' = 'Graiguecullen-Portarlington LEA',
                                    'Cavan - Belturbet LEA' = 'Cavan-Belturbet LEA',
                                    'Bandon - Kinsale LEA' ='Bandon-Kinsale LEA',
                                    'Bailieborough - Cootehill LEA' = 'Bailieborough-Cootehill LEA',
                                    'Laytown  Bettystown-lea' = 'Laytown-Bettystown LEA',
                                    'DÃºn Laoghaire LEA' = 'Dún Laoghaire-Rathdown County Council'))
```

```{r results='hide', echo=FALSE}
print('Number of unique id: ') 
print(n_distinct(df$id))
print('Number of rows: ')
print(nrow(df))
```
### Neighbourhood Group (renamed to 'council')
```{r echo=FALSE}
# renaming neighbourhood_group to council because this is more accurate name
df<- rename(df, council = neighbourhood_group)

# declaring column as a factor
df$council <- as.factor(df$council)

# some values were still incorrect so they were manually changed
df$council <- str_replace(df$council, 'Dun Laoghaire-rathdown County Council', 'Dún Laoghaire-Rathdown County Council')
```

### New Variable: County
A new variable 'county' was created from 'neighbourhood_group'. Several counties may have two or more county or city councils such as Cork, which has two councils: Cork City Council and Cork County Council. County Galway has two councils too: Galway City Council and Galway County Council.  Dublin has several councils: Fingal County Council, South Dublin County Council, Dún Laoghaire-Rathdown County Council, Dublin County Council. Some councils have two in one like Limerick City And County Council. To find out the county, string manipulation was conducted.

```{r echo=FALSE}
# getting rid of County Council from the council to assign county
df$county <- str_replace(df$council, ' County Council', '')
df$county <- str_replace(df$county, ' City Council', '')
df$county <- str_replace(df$county, ' City And', '')

# neighbourhood group in Dublin
df$county <- str_replace(df$county, 'Dún Laoghaire-Rathdown', 'Dublin')
df$county <- str_replace(df$county, 'Fingal', 'Dublin')
df$county <- str_replace(df$county, 'South Dublin', 'Dublin')

# assigning factor to country
df$county <- as.factor(df$county)
```

```{r}
unique(df$county)
```


```{r results='hide', echo=FALSE}
print('Number of unique id: ') 
print(n_distinct(df$id))
print('Number of rows: ')
print(nrow(df))
```

### New Variable: 90-Day Threshold
Homeowners in RTZs (RPZs) are required to apply for planning permission if they let out their entire home (principal private residence) for short-term lets of more than 90 days in total while they are away. Principal private residence is the place where one ordinarily live (Citizensinformation.ie, no date).

A new variable 'threshold_day_90' was created to state whether the listing is 'under-90' or 'over-90' days. 

```{r echo=FALSE}
df <- df %>%  
  mutate(threshold_day_90 = if_else(availability_365 < 90, 'under-90', 'over-90'))

# assigning factor to threshold_day_90
df$threshold_day_90 <- as.factor(df$threshold_day_90)
```

```{r echo=FALSE}
# examining the count of threshold_day_90 
df %>% 
  select(threshold_day_90) %>% 
  group_by(threshold_day_90) %>% 
  summarise(count = n())
```

### Room Type
```{r echo=FALSE}
# personal preference 
df$room_type <- str_replace(df$room_type, 'Entire home/apt', 'Entire rental unit')
```

There are 4 room types: `r unique(df$room_type)`. However, hotels have planning permission with relevant authorities to host guests and lease rooms, therefore, hotels will be dropped from the data. Because of the small amount of shared rooms in the dataset, shared room were also dropped. 

```{r echo=FALSE}
df %>% 
  select(room_type) %>% 
  group_by(room_type) %>% 
  summarise(count = n()) %>% 
  arrange(desc(count))
```

```{r echo=FALSE}
# removing hotel
df <-  df %>% 
  filter(!(room_type == 'Hotel room' | room_type == 'Shared room')) 
```

```{r echo=FALSE}
# declaring column as a factor
df$room_type <- as.factor(df$room_type)
```

```{r}
# examining room type available in Room Type
unique(df$room_type)
```


### Dateset 'summarise_df'
Dateset 'summarise_df'  was created from 'calendar.csv', which was downloaded from the AirBnB website. It was downloaded from http://insideAirBnB.com/get-the-data.html (calendar.csv).  This dataset is between  1st July 2024 to 28th June 2025. This dataset states whether the AirBnB listing is available on a specific date.

To examine how this dataset was created please see Rmd file called 'calendar_df.Rmd'

```{r}

DIRECTORY = "data_2024"

# specifying the path to the CSV file
file_path <- here(DIRECTORY, "summarise_df.csv")

# Read the CSV file
summarise_df <- read_csv(file_path)

summarise_df <- summarise_df%>%
  arrange(listing_id)


summarise_df$listing_id <- as.factor(summarise_df$listing_id)


```

In 'summarise_df' dataset, there are `r nrow(summarise_df)` rows and `r ncol(summarise_df)` columns in the dataset.
Columns names are  `r colnames(summarise_df)`.
```{r}
#check the class of summarise_df
class(summarise_df)
```

```{r}
#check the column names for  summarise_df
colnames(summarise_df)
```

```{r}
# examining the structure in summarise_df
str(summarise_df)
```

```{r}
# examining the top 5 rows in summarise_df
head(summarise_df)
```

```{r}
# examining summary of all numeric columns in summarise_df
summary(summarise_df)
```

### Data Dictionary
| Field | Type  | Description |
|:-|:-|:-|
| listing_id | integer | AirBnB's unique identifier for the listing |
| month | date | Month of the year |
| count | integer | Number of nights available in that month |
| min_price | integer | Minimum price for that listing in that month |
| mean_price | integer | Mean price for that listing in that month |
| max_price | integer | Maximum price for that listing in that month |


## Availability and Price Missing Values
```{r}

print('HOw many listings have missing availability?')
df %>%
  filter((is.na(availability_365)) | (availability_365 ==0))  %>%
  summarise(n = n_distinct(id)) %>%
  pull()
  

print('HOw many listings have missing price?')
df %>%
  filter((is.na(price)) | (price ==0))  %>%
  summarise(n = n_distinct(id)) %>%
  pull()
  

# CREATED A ORIGIAL so I dont have to rerun code from the top and wait for HOURS....
original_df <- df


print('If we drop listings all missing availability and price?')
df %>%
  filter(!(availability_365 ==0))  %>%
  filter(!(is.na(price)) |!(price ==0))   %>%
  summarise(n = n_distinct(id)) %>%
  pull()
  


no_missing_values_original_df <- df %>%
  filter(!(availability_365 ==0))  %>%
  filter(!(is.na(price)) |!(price ==0)) 

no_missing_values_original_df
```

### Dateset 'available_nights_df' 
Dateset 'available_nights'  was created from 'calendar.csv', which was downloaded from the AirBnB website. It was downloaded from http://insideAirBnB.com/get-the-data.html (calendar.csv).  This dataset is between 1st July 2024 to 25th July 2025. This dataset states whether the AirBnB listing is available on a specific date.

To examine how this dataset was created please see Rmd file called 'calendar_df.Rmd'

```{r}

# specifying the path to the CSV file
file_path <- here(DIRECTORY, "available_nights_df.csv")

# Read the CSV file
available_nights_df <- read_csv(file_path)


available_nights_df <- available_nights_df%>%
  arrange(listing_id)

available_nights_df$listing_id <- as.factor(available_nights_df$listing_id)



```

In 'available_nights_df' dataset, there are `r nrow(available_nights_df)` rows and `r ncol(available_nights_df)` columns in the dataset.
Columns names are  `r colnames(available_nights_df)`.
```{r}
#check the class of available_nights_df
class(available_nights_df)
```

```{r}
#check the column names for  available_nights_df
colnames(available_nights_df)
```

```{r}
# examining the structure in available_nights_df
str(available_nights_df)
```

```{r}
# examining the top 5 rows in available_nights_df
head(available_nights_df)
```

```{r}
# examining summary of all numeric columns in available_nights_df
summary(available_nights_df)
```


```{r}

total_nights_available = summarise_df %>%
  group_by(listing_id) %>%
  summarise(total_nights_available = sum(count), 
            total_nights_available_price = mean(mean_price))

```

### Data Dictionary
| Field | Type  | Description |
|:-|:-|:-|
| listing_id | integer | AirBnB's unique identifier for the listing |
| available_nights | integer | Number of nights available during the year |
| total_nights_available_price | integer | Average price per night during the year |

### Merging df and availability_df


```{r}
# Merging based on different column names
merged_df <- merge(df, total_nights_available, by.x = "id", by.y = "listing_id")

merged_df 
```

```{r}
# Merging based on different column names
df <- df%>%
  mutate(sub_id = substr(id, 1, 7))

sub_merged_df <- merge(df, total_nights_available, by.x = "sub_id", by.y = "listing_id")

sub_merged_df 

```

```{r}
sum(is.na(merged_df$availability_365))

sum(is.na(merged_df$price))

sum(is.na(merged_df$total_nights_available))

sum(is.na(merged_df$total_nights_available_price))
```

## Avaialability Issue
Boolean shows that 24 rows have a different availability stated for the listing. This is not a big number so by exploring the availability further, it will be possible to make a decision. 
```{r}
merged_df %>%
  select(availability_365, total_nights_available) %>%
  mutate(availability_does_not_match_between_merged_datasets = availability_365 == total_nights_available) %>%
  group_by(availability_does_not_match_between_merged_datasets) %>%
  summarise(n = n())

```


The 24 rows below are examined below. The total_nights_available is based of the calendar.df data, while availability_365 is from the listings data. 
```{r}
#
merged_df %>%
  select(availability_365, total_nights_available) %>%
  mutate(availability_does_not_match_between_merged_datasets = availability_365 ==total_nights_available,
         diff =  availability_365  - total_nights_available) %>%
  filter(availability_does_not_match_between_merged_datasets == FALSE) %>%
  summary()

```

Observation spots 2 interesting points: the ones that do not match AND Nas. That means that our dataset has missing values in the price.

```{r}
 
merged_df %>%
  select(price, total_nights_available_price) %>%
  mutate(boolena = price == total_nights_available_price) %>%
  group_by(boolena) %>%
  summarise(n = n())

```


```{r}
 
merged_df %>%
  select(price, total_nights_available_price) %>%
  mutate(price_does_not_match_between_merged_datasets = total_nights_available_price ==price,
         diff = total_nights_available_price - price ) %>%
  filter(price_does_not_match_between_merged_datasets == FALSE)  %>%
  summary()

```


```{r}
 
print(summary(merged_df$price))


print(summary(merged_df$total_nights_available_price) )

```

 Eploring the 671 rows that have missing value for a boolean. 
```{r}
 
merged_df %>%
  select(id, availability_365, total_nights_available, price, total_nights_available_price) %>%
  mutate(price_does_not_match_between_merged_datasets = total_nights_available_price ==price) %>%
  filter(is.na(price_does_not_match_between_merged_datasets))

```


## Decision Time
```{r}
 

# Rename column A to B
df <- merged_df %>%
  
  ######
  # Dealing with Availability
  ######
  # Dropping the availability_365 (from df because it had more missing values than the summarise_df)
  select(-availability_365) %>%
  rename(availability_365 = total_nights_available) %>%
  
  ######
  # dealing with price combining
  ######  
  select(-price) %>%
  rename(price = total_nights_available_price) 
  
```




There were `r sum(is.na((df$price)))` rows with missing price, while `r sum(is.na((df$availability_365)))` had missing availability. It was decided to drop the listings that had no price point. 



```{r}
df <-  df %>%
    # 264 rows have no price
  filter(!(is.na(price)) | (is.na(availability_365))) 

print(summary(df$price))
print(summary(df$availability_365))
  
```

### New Variable: Occupancy
Availability and occupancy is two different things. 

Availability refers to how nights each Airbnb is available for, while occupancy refers to the number of nights guests paid to stay in the property. 

It was decided to ASSUME occupancy as 80% of all available nights. 

How did I get this number? I googled what is a good occupancy rate and Google said 60-70 :)
(Huge limitations with this figure of course)

```{r echo=FALSE}
df <- df %>%  
  mutate(occupancy_70_per = round(availability_365* 0.7))

```

### New Variable: Airbnb Potential Annual Income

Creating a new variable 'airbnb_potential_annual_income', examining the full income potential of a listings by multiplying the price by the number of OCCUPIED nights. 

```{r echo=FALSE}

df <- df %>%  
  mutate(airbnb_potential_annual_income = price*occupancy_70_per)

```

```{r}
summary(df$airbnb_potential_annual_income)
```

```{r echo=FALSE}
df %>%
  plot_ly(x = ~airbnb_potential_annual_income) %>% 
  add_histogram() %>% 
  layout(xaxis = list(title = "Total Income"),
          yaxis = list(title = "Number of Observations"),
          title = "Histogram of Total Income")
```

### Rent Pressure Zones
Rent Pressure Zones (RPZs) were developed by the Irish government to tackle rising rents lack of affordable rental units. These are areas located in parts of the country where rents are the highest and rising, and where households have the greatest difficulty finding affordable accommodation (Residential Tenancies Board, 2027). The csv was manually created from RTB website. 

```{r}

# specifying the path to the CSV file
file_path <- here(DIRECTORY, "rent_pressure_zones.csv")

# Read the CSV file
rpz_df <- read_csv(file_path, show_col_types = FALSE)

```

In 'rpz_df' dataset, there are `r nrow(rpz_df)` rows and `r ncol(rpz_df)` columns. Columns names are  `r colnames(rpz_df)`.
```{r}
#check the class of rpz_df
class(rpz_df)
```

```{r}
#check the column names for  rpz_df
colnames(rpz_df)
```

```{r}
# examining the structure in rpz_df
str(rpz_df)
```

```{r}
# examining the top 5 rows in rpz_df
head(rpz_df)
```

```{r}
# examining summary of all numeric columns in rpz_df
summary(rpz_df)
```



```{r}
unique_neighbourhoods <- unique(rpz_df$neighbourhood)

unique_neighbourhoods_list <- as.list(unique_neighbourhoods)
```



### Data Dictionary
| Field | Type  | Description |
|:-|:-|:-|
| neighbourhood | text | LEA or County Council e.g. Kildare County Council and Naas LEA |
| rpz | logical | Stating whether the area is in RTZs (RPZ): true or false |

### New Variable: RTZ

The column 'county_city' in 'rpz_df' had values which contained both values from columns 'council' and 'lea'. In this case, a new column had to be created stating whether the listing is a RTZ or not. 

```{r echo=FALSE}
unique(rpz_df$neighbourhood)
```

```{r echo=FALSE}
# Creating a new variable 
# Manually assessing whether it is TRUE or FALSE
# the list was taken from 'neighbourhood' in 'rpz_df' dataset
df <- df %>%  
  mutate(
    rent_pressure_zone = case_when(
      str_detect(council, 'Cork City Council') ~ TRUE,
      str_detect(council, 'Dublin City Council') ~ TRUE,
      str_detect(council, 'Dún Laoghaire-Rathdown County Council') ~ TRUE,
      str_detect(council, 'Fingal County Council') ~ TRUE,
      str_detect(council, 'South Dublin County Council') ~ TRUE,
      str_detect(council, 'Kildare County Council') ~ TRUE,
      str_detect(lea, 'Ballincollig–Carrigaline LEA') ~ TRUE,
      str_detect(lea, 'Galway City Central LEA') ~ TRUE,
      str_detect(lea, 'Galway City West LEA') ~ TRUE,
      str_detect(lea, 'Galway City East LEA') ~ TRUE,
      str_detect(lea, 'Drogheda LEA') ~ TRUE,
      str_detect(lea, 'Drogheda Urban LEA') ~ TRUE,
      str_detect(lea, 'Drogheda Rural LEA') ~ TRUE,
      str_detect(lea, 'Celbridge-Leixlip LEA') ~ TRUE,
      str_detect(lea, 'Naas LEA') ~ TRUE,
      str_detect(lea, 'Newbridge LEA') ~ TRUE,
      str_detect(lea, 'Ashbourne LEA') ~ TRUE,
      str_detect(lea, 'Laytown-Bettystown LEA') ~ TRUE,
      str_detect(lea, 'Ratoath LEA') ~ TRUE,
      str_detect(lea, 'Bray West LEA') ~ TRUE,
      str_detect(lea, 'Bray East LEA') ~ TRUE,
      str_detect(lea, 'Wicklow LEA') ~ TRUE,
      str_detect(lea, 'Cobh LEA') ~ TRUE,
      str_detect(lea, 'Maynooth LEA') ~ TRUE,
      str_detect(lea, 'Drogheda LEA') ~ TRUE,
      str_detect(lea, 'Greystones LEA') ~ TRUE,
      str_detect(lea, 'Limerick City East LEA') ~ TRUE,
      str_detect(lea, 'Navan LEA') ~ TRUE,
      str_detect(lea, 'Fermoy LEA') ~ TRUE,
      str_detect(lea, 'Midleton LEA') ~ TRUE,
      str_detect(lea, 'Athenry-Oranmore LEA') ~ TRUE,
      str_detect(lea, 'Gort-Kinvara LEA') ~ TRUE,
      str_detect(lea, 'Kilkenny LEA') ~ TRUE,
      str_detect(lea, 'Graiguecullen-Portarlington LEA') ~ TRUE,
      str_detect(lea, 'Portlaoise LEA') ~ TRUE,
      str_detect(lea, 'Limerick City North LEA') ~ TRUE,
      str_detect(lea, 'Limerick City West LEA') ~ TRUE,
      str_detect(lea, 'Ardee LEA') ~ TRUE,
      str_detect(lea, 'Dundalk-Carlingford LEA') ~ TRUE,
      str_detect(lea, 'Dundalk South LEA') ~ TRUE,
      str_detect(lea, 'Kells LEA') ~ TRUE,
      str_detect(lea, 'Trim LEA') ~ TRUE,
      str_detect(lea, 'Waterford City East LEA') ~ TRUE,
      str_detect(lea, 'Waterford City South LEA') ~ TRUE,
      str_detect(lea, 'Athlone LEA') ~ TRUE,
      str_detect(lea, 'Gorey LEA') ~ TRUE,
      str_detect(lea, 'Arklow LEA') ~ TRUE,
      str_detect(lea, 'Carlow LEA') ~ TRUE,
      str_detect(lea, 'Macroom LEA') ~ TRUE,
      str_detect(lea, 'Cobh LEA') ~ TRUE,
      str_detect(lea, 'Piltown LEA') ~ TRUE,
      str_detect(lea, 'Sligo-Strandhill LEA') ~ TRUE,
      str_detect(lea, 'Baltinglass LEA') ~ TRUE,
      str_detect(lea, 'Mallow LEA') ~ TRUE,
      str_detect(lea, 'Killarney LEA') ~ TRUE,
      str_detect(lea, 'Athy LEA') ~ TRUE,
      str_detect(lea, 'Tullamore LEA') ~ TRUE,
      str_detect(lea, 'Mullingar LEA') ~ TRUE,
      str_detect(lea, 'Bandon-Kinsale LEA') ~ TRUE,
      str_detect(lea, 'Westport LEA') ~ TRUE,
      str_detect(lea, 'Shannon LEA') ~ TRUE,
      str_detect(lea, 'Ennis LEA, Co. Clare') ~ TRUE,
      str_detect(county, 'Kilkenny') ~ TRUE,
      str_detect(county, 'Limerick') ~ TRUE,
      str_detect(county, 'Waterford') ~ TRUE,
      str_detect(county, 'Westmeath') ~ TRUE,

     
      
      TRUE ~ FALSE)) 


# changing TRUE to 'RPZ' (RTZ) 
df$rent_pressure_zone <- str_replace(df$rent_pressure_zone, 'TRUE', 'RPZ')

# changing False to 'Non-RPZ' (Non RTZ) 
df$rent_pressure_zone <- str_replace(df$rent_pressure_zone, 'FALSE', 'Non-RPZ')

# assigning factor to rent_pressure_zone  variable
df$rent_pressure_zone <- as.factor(df$rent_pressure_zone)
```

```{r results='hide', echo=FALSE}
unique(df$rent_pressure_zone)
```

```{r echo=FALSE}
# examining the count of rent_pressure_zone TRUE or FALSE
df %>% 
  select(rent_pressure_zone) %>% 
  group_by(rent_pressure_zone) %>% 
  summarise(count = n())
```

### Rent Prices in Ireland
The website daft.ie is the leading property website in Ireland, which publishes reports on the Irish housing market every quarter. For this next dataset, the report Q1 2024 was used to find out the rent in each city and county in Ireland (Lyons, 2024). The csv was manually created from the report. 

```{r}

# specifying the path to the CSV file
file_path <- here(DIRECTORY, "rent_in_ireland.csv")

# Read the CSV file
rent_df <- read_csv(file_path)

```

In 'rent_df' dataset, here are `r nrow(rent_df)` rows and `r ncol(rent_df)` columns. Columns names are `r colnames(rent_df)`.
```{r}
#check the class of rent_df
class(rent_df)
```

```{r}
#check the column names for  rent_df
colnames(rent_df)
```

```{r}
# examining the structure in rent_df
str(rent_df)
```

```{r}
# examining the top 5 rows in rent_df
head(rent_df)
```

```{r}
# examining summary of all numeric columns in rent_df
summary(rent_df)
```

### Data Dictionary
| Field | Type  | Description |
|:-|:-|:-|
| county_city | text | County or City, e.g. County Galway and Galway City |
| rent_potential_annual_income_per_month | integer | Average price of a rental property in an area |


### Merging Datasets: 'df' with 'rent_df'
In 'df' dataset, a new column 'county_city' was created from 'council' to be the same as 'county_city' in 'rent_df'. 

```{r}
unique(rent_df$county_city)
```



```{r}
unique(df$council)
```

```{r}
df %>%
  filter(county =='Limerick') %>%
  group_by(county, council, lea) %>%
  summarise(n = n())
```

```{r echo=FALSE, warning=FALSE}
# Applying case_when logic
df <- df %>%
  mutate(
    rent_council_city = case_when(
      lea == 'Tramore-Waterford City West LEA' ~ 'Waterford City',
      lea == 'Waterford City East LEA' ~ 'Waterford City',
      lea == 'Waterford City South LEA' ~ 'Waterford City',
      lea == 'Limerick City East LEA' ~ 'Limerick City',
      lea == 'Limerick City North LEA' ~ 'Limerick City',
      lea == 'Limerick City West LEA' ~ 'Limerick City',
      TRUE ~ council
    )
  )


df$rent_council_city <- str_replace(df$rent_council_city, ' County Council', '')
df$rent_council_city <- str_replace(df$rent_council_city, ' City And', '')
df$rent_council_city <- str_replace(df$rent_council_city, ' Council', '')
df$rent_council_city <- str_replace(df$rent_council_city, 'Dún Laoghaire-Rathdown', 'Dublin City')
df$rent_council_city <- str_replace(df$rent_council_city, 'South Dublin', 'Dublin City')
df$rent_council_city <- str_replace(df$rent_council_city, 'Fingal', 'Dublin City')



unique(df$rent_council_city)

```



```{r results='hide', echo=FALSE}
pre_merge_nrow <- nrow(df)
pre_merge_n_distinct <- n_distinct(df$id)

print('Number of unique id: ') 
print(pre_merge_n_distinct)
print('Number of rows: ')
print(pre_merge_nrow)


```

```{r echo=FALSE}
# Print unique values from both lists
print('RENT COUNCIL CITY')
print(unique(df$rent_council_city))


print('RENT DF')
print(unique(rent_df$county_city))

rent_council_city_list <-  as.list(df$rent_council_city)
rent_df_list <- as.list(rent_df$county_city)


# Find elements in rent_council_city that are not in rent_df
not_in_rent_df <- setdiff(rent_council_city_list, rent_df_list)
print('Elements in RENT COUNCIL CITY not in RENT DF:')
print(not_in_rent_df)

# Find elements in rent_df that are not in rent_council_city
not_in_rent_council_city <- setdiff(rent_df_list, rent_council_city_list)
print('Elements in RENT DF not in RENT COUNCIL CITY:')
print(not_in_rent_council_city)
```


```{r echo=FALSE}
# Datasets 'df' and 'rent_df' were merged on column 'county_city'.
df <- merge(df, rent_df, by.x = "rent_council_city", by.y = "county_city")
```

```{r rresults = hidden, echo=FALSE}

df %>%
  filter(is.na(rent_council_city))
```


```{r results='hide', echo=FALSE}
# Checking we did not drop any rows during the merge!

post_merge_nrow <- nrow(df)
post_merge_n_distinct <- n_distinct(df$id)

print('Are the number of rows pre- and post- merge the same? ')
pre_merge_nrow == post_merge_nrow
pre_merge_n_distinct == post_merge_n_distinct

```


## New Variable: Potential Incom from Rent - Per day and Annually
Using rent_df (dataset with county or city and average rent), A new variable was calculated 'rent_potential_annual_income_per_day' which is the rent the tenant pays per day to stay in their rented property. Although this is not how this is not normally used in the renting market, this variable will be compared to the price of AirBnB, which is in 'per day'. It was decided to find the rent per day, because not all properties are leased for 365 days a year.

It was also assumed that private rooms will cost one third of an entire house to rent, i.e. if a house's rent is €1500, then a room to rent is €500. Although this is not the most accurate estimate, it is better than assuming that the price of a private room is the same as a rent of the whole house, i.e. €1500 for private room. This was also operated under the assumptions that all rooms in the house are the same size and have the same bathroom privileges, i.e. all en suite or all sharing.


```{r echo=FALSE}
# if the property is 'Entire rental unit'. then multiply rent_potential_annual_income_per_month by 12 (months) and divide by 365 (days)
# otherwise ('Private room' or 'Shared room') multiply rent_potential_annual_income_per_month by 12 (months), divide by 365 (days) and divide by 3 (rooms in the house)
df <- df %>%  
  mutate(rent_potential_annual_income_per_day = if_else(room_type == 'Entire rental unit', (rent_price_per_month*12)/365, ((rent_price_per_month*12)/365)/3))
```


```{r echo=FALSE}
# if the property is 'Entire rental unit'. then multiply rent_potential_annual_income_per_month by 12 (months) 
# otherwise ('Private room' or 'Shared room') multiply rent_potential_annual_income_per_month by 12 (months) and divide by 3 (rooms in the house)
df <- df %>%  
  mutate(rent_potential_annual_income = if_else(room_type == 'Entire rental unit', rent_price_per_month * 12, (rent_price_per_month*12)/3))
```

### New Variable: Rent or AirBnB?
New variable was created to examine whether the property should be rented or AirBnB listing.

Some thought was given to whether to compare AirBnB daily price and rent per day OR total income possible from AirBnB and total income from rent. Although comparing daily AirBnB and rent per day would allow to compare the income the landlord would get on per day, it does not show whether it is actually worth while listing the property on AirBnB bringings in more earnings than renting when taking in consideration the amount of nights that the property is available. Two varialbes were developed to examine this: per day and per year.  
If the AirBnB price is greater than price, then the property should be an AirBnB listing.
If the AirBnB price is lower than price, then the property should be rented.

```{r echo=FALSE}
# creating a new variable to state whether the property should be rented or on AirBnB
df <- df %>%  
  mutate(best_choice_airbnb_or_rent_per_day = if_else(price >= rent_potential_annual_income_per_day, 'AirBnB', 'Rent'))


# assigning factor to per_day_rent_AirBnB
df$best_choice_airbnb_or_rent_per_day <- as.factor(df$best_choice_airbnb_or_rent_per_day)
```

```{r echo=FALSE}
# examining the count of per_day_rent_AirBnB
df %>% 
  select(best_choice_airbnb_or_rent_per_day) %>% 
  group_by(best_choice_airbnb_or_rent_per_day) %>% 
  summarise(count = n())

```

``` {r echo=FALSE}
# creating a new variable to state whether the property should be rented or on AirBnB
df <- df %>%  
  mutate(best_choice_airbnb_or_rent_per_year = if_else(airbnb_potential_annual_income >= rent_potential_annual_income, 'AirBnB', 'Rent'))

# assigning factor to best_choice_airbnb_or_rent_per_year
df$best_choice_airbnb_or_rent_per_year <- as.factor(df$best_choice_airbnb_or_rent_per_year)
```

```{r echo=FALSE}
# examining the count of per_day_rent_AirBnB
df %>% 
  select(best_choice_airbnb_or_rent_per_year) %>% 
  group_by(best_choice_airbnb_or_rent_per_year) %>% 
  summarise(count = n())

```

```{r echo=FALSE}
# examining the count of per_day_rent_AirBnB
df %>% 
  select(id, county,room_type, availability_365, price, airbnb_potential_annual_income, #rent_price_per_month, 
         rent_potential_annual_income, best_choice_airbnb_or_rent_per_year #,annual_diff_rent_minus_Airbnb
         )  %>%
  filter(is.na(best_choice_airbnb_or_rent_per_year))

```

### New Variable: Difference in Earnings - Long-Term or Airbnb - Numbers

```{r message=FALSE, echo=FALSE}


# If POSITIVE, then AIRBNB brings more income
# If NEGATIVE, then RENT brings more income
df <- df %>%
  mutate(annual_diff_rent_minus_Airbnb = airbnb_potential_annual_income -  rent_potential_annual_income)
```

### New Variable: Planning Permission
Creating a new variable 'planning_permission' in 'df' dataset to examine whether planning permission is required for the AirBnB listing. As stated above, an AirBnB listings of an entire property over 90 days in RTZ requires planning permission with the local authorites. New column will state whether planning permission is required or not. 
```{r echo=FALSE}
df <- df %>%  
  mutate(planning_permission = if_else((room_type == 'Entire rental unit' & threshold_day_90 == 'over-90' & rent_pressure_zone =='RPZ'), 'Planning Required', 'Not Required'))  
```


```{r echo=FALSE}

# examining the count of planning_permission 
df %>% 
  select(planning_permission) %>% 
  group_by(planning_permission) %>% 
  summarise(count = n())

```


### New Variable: Months Category
Creating a new variable 'planning_permission' in 'df' dataset to examine whether planning permission is required for the AirBnB listing. As stated above, an AirBnB listings of an entire property over 90 days in RTZ requires planning permission with the local authorites. New column will state whether planning permission is required or not. 
```{r echo=FALSE}
# Assuming sum_df is your dataset with availability_365 column
df <- df %>%
  mutate(month_category = case_when(
    availability_365 <= 30 ~ "1 month",
    availability_365 <= 61 ~ "2 months",
    availability_365 <= 91 ~ "3 months",
    availability_365 <= 122 ~ "4 months",
    availability_365 <= 152 ~ "5 months",
    availability_365 <= 183 ~ "6 months",
    availability_365 <= 213 ~ "7 months",
    availability_365 <= 244 ~ "8 months",
    availability_365 <= 274 ~ "9 months",
    availability_365 <= 305 ~ "10 months",
    availability_365 <= 335 ~ "11 months",
    availability_365 <= 365 ~ "12 months",
    TRUE ~ "More than 12 months"  # Covering cases beyond 1 year (365 days)
  ))


# changing  the order of factors
df$month_category <- factor(df$month_category, levels = c("1 month", 
                                                            "2 months",
                                                            "3 months",
                                                            "4 months",
                                                            "5 months",
                                                            "6 months",
                                                            "7 months",
                                                            "8 months",
                                                            "9 months",
                                                            "10 months",
                                                            "11 months",
                                                            "12 months",
                                                            "More than 12 months"
                                                            ))
# Print the first few rows to check
head(df)

```

### New Datasets: 'df' with 'summarise_df'
Dataset 'df' was merged with 'summarise_df' using 'listing_id' in 'available_nights_df' and 'id' in 'df'. 

```{r echo=FALSE}
# merging the dataset together
large_df<- merge(df, summarise_df, by.x = "id", by.y = "listing_id")
```

```{r}
names(large_df)
```


```{r echo=FALSE}
# dropping irrelevant columns
drop = c("id","host_id", "month", "count", "county", "room_type","term", 
         "availability_365", "county" ,                              
"rent_price_per_month" ,
"rent_potential_annual_income_per_day",
"rent_potential_annual_income",
"best_choice_airbnb_or_rent_per_day","best_choice_airbnb_or_rent_per_year",
"annual_diff_rent_minus_Airbnb","rent_pressure_zone", "threshold_day_90", "planning_permission", "month_category"                       
         
         )

large_df <- large_df[names(large_df) %in% drop] 
```

```{r}
names(df)
```

In the final 'large_df' dataset, there are `r nrow(large_df) ` rows and `r ncol(large_df)` columns. Columns names are  `r colnames(large_df)`. 

```{r echo=FALSE}
str(large_df)
```

```{r echo=FALSE}
nrow(large_df)
```

```{r echo=FALSE}
ncol(large_df)
```

```{r echo=FALSE}
head(large_df)
```

### Data Dictionary
| Field | Type  | Description |
|:-|:-|:-|
| id | integer | AirBnB's unique identifier for the listing |
| host_id | integer | Host's unique identifier |
| month | date | Month of the year |
| min_price | integer | Minimum price for that listing in that month |
| mean_price | integer | Mean price for that listing in that month |
| max_price | integer | Maximum price for that listing in that month |
| count | integer | Number of nights available in that month |
| county | text | County of AirBnB Listing |
| room_type | logical | Room type: Entire rental unit, Private room, Shared room |
| threshold_day_90 | text | Whether over-90 or under-90 days |
| term | text | Whether the AirBnB listing is available for long-term lease or short-term lease |
| per_day_rent_AirBnB  | text | Whether the property should be AirBnBed or rented our based on daily price |
| best_choice_airbnb_or_rent_per_year | text | Whether the property should be AirBnBed or rented our based on potential income |


# Final Dataset
In the final 'df' dataset, there are `r nrow(df) ` rows and `r ncol(df)` columns. Columns names are  `r colnames(df)`. 

Because our dataset was has been merged with 'available_nights_df', as described above, our dataset has AirBnB listings only available from 1st July 2024 to 25th July 2025. Any past AirBnB are not included in our dataset. 

```{r echo=FALSE}
summary(df)
```

```{r echo=FALSE}
nrow(df)
```

```{r echo=FALSE}
ncol(df)
```
### Data Dictionary
| Field | Type  | Description |
|:-|:-|:-|
| id | integer | AirBnB's unique identifier for the listing |
| name | text | Title of the property on AirBnB |
| host_id | interger | AirBnB's unique identifier for the host |
| host_name | text | Host's name |
| lea | text | Local Electoral Areas (LEAs) |
| council | text | County or City Council  |
| county | text | County of the AirBnB Listing  |
| latitude | numeric | Uses the World Geodetic System (WGS84) projection for latitude and longitude |
| longitude | numeric | Uses the World Geodetic System (WGS84) projection for latitude and longitude |
| room_type | string | Entire rental unit, Private room, Shared room, Hotel room |
| price | currency | Daily price in local currency |


```{r echo=FALSE}
df %>%
  select(id, county,room_type, availability_365, price, airbnb_potential_annual_income, #rent_price_per_month, 
         rent_potential_annual_income, best_choice_airbnb_or_rent_per_year,annual_diff_rent_minus_Airbnb) 
```




```{r echo=FALSE}
# Define the file path using here
file_path <- here(DIRECTORY, "airbnb_final_df_2024.csv")

# Save the dataframe as a CSV file
write.csv(df, file = file_path, row.names = FALSE)

###################
# Define the file path using here
file_path <- here(DIRECTORY, "airbnb_large_df_2024.csv")
# Save the dataframe as a CSV file
write.csv(large_df, file = file_path)
```

## Data Sources

Lyons, R. (2024) *Irish Rental Report Q1 2024.* Available at: https://ww1.daft.ie/report/ronan-lyons-2021
q2-daftrentalprice?d_rd=1 (Accessed: 28th June 2024).

Residential Tenancies Board (2024) *What are Rent Pressure Zones (RPZ)?* Available at: https://www.rtb.ie/registration-and-compliance/setting-and-reviewing-rent/guide-to-rent-pressure-zones (Accessed: 31 July 2024).


```{r}

#RPZ or Non-RPZ
pressure_colors = c( "#316395", "#D62728")

# creating a map of Ireland with AirBnB listings in RTZ differentiated 
g <- list(
  scope = 'europe',
  showland = TRUE,
  landcolor = toRGB("gray95"),
  subunitcolor = toRGB("gray85"),
  countrycolor = toRGB("gray85"),
  countrywidth = 0.5,
  subunitwidth = 0.5,

  resolution = 50,
  lonaxis = list(range = c(-12, -5)),
  lataxis = list(range = c(52, 55))
)



unique_id_df <- df %>%
  group_by(id, rent_pressure_zone, 
           lea, council, county, room_type, latitude, longitude) %>%
  summarise(price = mean(price))

fig <- plot_geo(df, lat = ~latitude, lon = ~longitude, color = ~rent_pressure_zone)
fig <- fig %>% add_markers(marker = list(opacity = 0.2), showlegend=FALSE, colors = pressure_colors,
                          
                          hovertemplate = ~paste("LEA:", lea, "<br>", 
                                        "Council:", council, "<br>",
                                        "Price (in €):", price, "<br>",

                                        
                                        "County:", county, "<br>",
                                        "Room Type", room_type, "<br>",
                                        "RTZ", rent_pressure_zone, "<br>"))
fig <- fig %>% layout(
    title = 'Which AirBnB listings are in the RTZs?', geo = g)

fig
```


```{r}
df

```
